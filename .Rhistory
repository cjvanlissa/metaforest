#' method uses all trees from both forests.
#' @param formula Formula. Specify a formula for the MetaForest model, for
#' example, \code{yi ~ .} to predict the outcome \code{yi} from all moderators
#' in the data.
#' @param data Data.frame. Provide a data.frame containing the effect size,
#' moderators, and the variance of the effect size.
#' Defaults to 100.
#' @param vi Character. Specify the name of the column in the \code{data} that
#' contains the variances of the effect sizes. This column will be removed from
#' the data prior to analysis. Defaults to \code{"vi"}.
#' @param study Character. Specify the name of the column in the \code{data} that
#' contains the study id. This column can be a vector of integers, or a factor.
#' This column will be removed from the data prior to analysis.
#' @param whichweights Character. Indicate what time of weights are required.
#' A random-effects MetaForest is grown by specifying \code{whichweights =
#' "random"}. A fixed-effects MetaForest is grown by specifying
#' \code{whichweights = "fixed"}. An unweighted MetaForest is grown by
#' specifying \code{whichweights = "unif"}. Defaults to \code{"random"}.
#' @param num.trees Atomic integer. Specify the number of trees in the forest.
#' Defaults to 500.
#' @param mtry Atomic integer. Number of candidate moderators available for each
#' split. Defaults to the square root of the number moderators (rounded down).
#' @param method Character. Specify the method by which to estimate the residual
#' variance. Can be set to one of the following: "DL", "HE", "SJ", "ML", "REML",
#' "EB", "HS", or "GENQ". Default is "REML".
#' See the \link[metafor]{metafor} package for more information.
#' @param tau2 Numeric. Specify a predetermined value for the residual
#' heterogeneity. Entering a value here supersedes the estimated tau2 value.
#' Defaults to NULL.
#' @param ... Additional arguments are passed directly to \link[ranger]{ranger}.
#' It is recommended not to use additional arguments.
#' @return List of length 3. The "forest" element of this list is an object of
#' class "ranger", containing the results of the random forests analysis. The
#' "rma_before" element is an object of class "rma.uni", containing the results
#' of a random-effects meta-analysis on the raw data, without moderators. The
#' "rma_after" element is an object of class "rma.uni", containing the results
#' of a random-effects meta-analysis on the residual heterogeneity, or the
#' difference between the effect sizes predicted by MetaForest and the observed
#' effect sizes.
#' @export
#' @examples
#' #Example 1: Simulated clustered data
#' #Make a mock data file
#' data <- data.frame(SimulateSMD(k_train = 100)$training, study=1:100)
#' #Run ClusterMF analysis
#' mf.cluster <- ClusterMF(yi~., data, study = "study")
#' #Check convergence plot
#' plot(mf.cluster)
#' #Check summary
#' summary(mf.cluster)
#'
#' #Load and clean data
#' data <- dat.bangertdrowns2004
#' data[, c(4:12)] <- apply(data[ , c(4:12)], 2, function(x){
#'   x[is.na(x)] <- median(x, na.rm = TRUE)
#'   x})
#' data$subject <- factor(data$subject)
#' data$yi <- as.numeric(data$yi)
#' mf.cluster.bb2004 <- ClusterMF(formula = yi~ grade + length + minutes + wic +
#'                                meta, data, study = "id",
#'                                whichweights = "unif")
#' #Print MetaForest object
#' mf.cluster.bb2004
#' #Check convergence plot
#' plot(mf.cluster.bb2004)
#' #Check summary
#' summary(mf.cluster.bb2004, digits = 4)
#'
#' mf.cluster.bb2004.random <- ClusterMF(formula = yi~ grade + length + minutes+
#'                                       wic + meta, data, study = "id",
#'                                       whichweights = "random", tau2 = 0.0462)
#' VarImpPlot(mf.cluster.bb2004.random)
#'
#' PartialDependence(mf.cluster.bb2004, vars = c("meta", "minutes"))
# library(metaforest)
#
# data <- data.frame(SimulateSMD(k_train = 100)$training, study=1:100)
# #Run ClusterMF analysis
# mf.cluster <- ClusterMF(yi~., data, study = "study")
# #Print MetaForest object
# mf.cluster
# #Check convergence plot
# plot(mf.cluster)
# #Check summary
# summary(mf.cluster)
#
# data <- get(data(dat.bourassa1996))
# data <- escalc(measure="OR", ai=lh.le, bi=lh.re, ci=rh.le, di=rh.re, data=data, add=1/2, to="all")
# data$mage[is.na(data$mage)] <- median(data$mage, na.rm = TRUE)
#
# data[c(5:8)] <- lapply(data[c(5:8)], factor)
# library(metaforest)
# data$yi <- as.numeric(data$yi)
mf.cluster.b1996 <- ClusterMF(formula = yi~.,
data, study = "sample", whichweights = "unif", num.trees = 1000)
# mf.cluster.b1996 <- ClusterMF(formula = yi~ selection + investigator + hand_assess + eye_assess + mage +sex,
#                                data, study = "sample", whichweights = "unif", num.trees = 1000)
# #Print MetaForest object
# mf.cluster.b1996
# #Check convergence plot
# plot(mf.cluster.b1996)
# #Check summary
# summary(mf.cluster.b1996, digits = 4)
#
# VarImpPlot(mf.cluster.b1996)
#
# PartialDependence(mf.cluster.b1996, vars = c("mage", "eye_assess"))
#
# is.numeric(data$study)
# is.factor(data$investigator)
# }
#        donttest{
#               further examples for users (not used for checks)
#        }
# }
ClusterMF <- function(formula, data, vi = "vi", study = NULL,
whichweights = "random", num.trees = 500, mtry = NULL,
method = "REML", tau2 = NULL, ...) {
if(is.null(study)){ stop("Please provide a valid \"study\" column name.")}
args <- match.call()
yi <- as.character(formula[2])
mods <- get_all_vars(formula, data)
if(vi %in% names(mods)) mods <- mods[-match(vi, names(mods))]
if(study %in% names(mods)) mods <- mods[-match(study, names(mods))]
vi <- data[[vi]]
study <- data[[study]]
data <- mods
if(!class(study) %in% c("integer", "numeric", "factor")) stop("Please provide a valid \"study\" column name.")
if ("case.weights" %in% names(args)) {
stop("Error: Argument 'case.weights' not supported in ClusterMF")
}
if ("holdout" %in% names(args)) {
stop("Error: Argument 'holdout' not supported in ClusterMF.")
}
if ("importance" %in% names(args)) {
stop("Error: Argument 'importance' not supported in ClusterMF. Always set to 'permutation'.")
}
if ("replace" %in% names(args)) {
stop("Error: Argument 'replace' not supported in ClusterMF.")
}
rma_before <- rma(yi = data[[yi]], vi = vi, method = method)
if(is.null(tau2)) tau2 <- rma_before$tau2
if (whichweights == "unif") {
metaweights <- rep(1, nrow(data))
}
if (whichweights == "fixed") {
metaweights <- (1/vi)
}
if (whichweights == "random") {
metaweights <- 1/(vi + tau2)
}
#Sample subsamples by cluster (study), calculate weights by subsample
unique_studies <- unique(study)
subsample_studies <- sample(unique_studies, round(length(unique_studies)/2))
subsample_studies <- list(sample1 = sort(subsample_studies), sample2 = unique_studies[!(unique_studies %in% subsample_studies)])
rm(unique_studies)
subsample_weights <- lapply(subsample_studies, function(samplestudies){
set_to_zero <- which(!(study %in% samplestudies))
ss_weights <- metaweights
ss_weights[set_to_zero] <- 0
(ss_weights / sum(ss_weights)) * length(which((study %in% samplestudies)))
})
res <- list(
rf1 = ranger(
formula = formula,
data = data,
num.trees = num.trees,
mtry = mtry,
importance = "permutation",
write.forest = TRUE,
case.weights = subsample_weights[[1]],
holdout = TRUE, ...),
rf2 = ranger(
formula = formula,
data = data,
num.trees = num.trees,
mtry = mtry,
importance = "permutation",
write.forest = TRUE,
case.weights = subsample_weights[[2]],
holdout = TRUE, ...)
)
## Compute importance
predicted <- res$rf1$predictions
predicted[is.na(predicted)] <- res$rf2$predictions[!is.na(res$rf2$predictions)]
observed <- data[[yi]]
residuals <- observed - predicted
rma_after <- rma(yi = residuals, vi = vi, method = method)
forest <- list(predictions = predicted,
num.trees = res$rf1$num.trees + res$rf2$num.trees,
num.independent.variables = res$rf1$num.independent.variables,
mtry = res$rf1$mtry,
min.node.size = res$rf1$min.node.size,
variable.importance = (res$rf1$variable.importance + res$rf2$variable.importance)/2,
prediction.error = mean(c(res$rf1$prediction.error, res$rf2$prediction.error)),
forest = list(dependent.varID = res$rf1$forest$dependent.varID,
num.trees = res$rf1$forest$num.trees + res$rf2$forest$num.trees,
child.nodeIDs = c(rbind(res$rf1$forest$child.nodeIDs, res$rf2$forest$child.nodeIDs)),
split.varIDs = c(rbind(res$rf1$forest$split.varIDs, res$rf2$forest$split.varIDs)),
split.values = c(rbind(res$rf1$forest$split.values, res$rf2$forest$split.values)),
is.ordered = res$rf1$forest$is.ordered,
independent.variable.names = res$rf1$forest$independent.variable.names,
treetype = res$rf1$forest$treetype),
#rf2 = res$rf2,
splitrule = res$rf1$splitrule,
treetype = res$rf1$treetype,
r.squared = 1 - mean(c(res$rf1$prediction.error, res$rf2$prediction.error)) / var(observed),
call = formula,
importance.mode = "permutation",
num.samples = res$rf1$num.samples,
cluster_forests = res
)
class(forest) <- "ranger"
class(forest$forest) <- "ranger.forest"
output <- list(forest = forest, rma_before = rma_before, rma_after = rma_after, call = args, data = data)
class(output) <- c("MetaForest")
output
}
mf.random <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "random", method = "DL",
tau2 = 0.2450)
mf.cluster.b1996 <- ClusterMF(formula = yi~.,
data, study = "sample", whichweights = "unif", num.trees = 1000)
mf.cluster.b1996
VarImpPlot(mf.cluster.b1996)
PartialDependence(mf.cluster.b1996, vars = c("mage", "eye_assess"))
#' Conduct a MetaForest analysis to explore heterogeneity in meta-analytic data.
#'
#' MetaForest uses a weighted random forest to explore heterogeneity in
#' meta-analytic data. MetaForest is a wrapper for \link[ranger]{ranger}
#' (Wright & Ziegler, 2015). As input, MetaForest takes the study effect sizes
#' and their variances (these can be computed, for example, using the
#' \link[metafor]{metafor} package), as well as the moderators that are to be
#' included in the model. By default, MetaForest uses random-effects weights,
#' and estimates the between-studies variance using a restricted
#' maximum-likelihood estimator. However, it may be beneficial to first conduct
#' an unweighted MetaForest, and then use the estimated residual heterogeneity
#' from this model as the estimate of \code{tau2} for a random-effects weighted
#' MetaForest.
#' @param formula Formula. Specify a formula for the MetaForest model, for
#' example, \code{yi ~ .} to predict the outcome \code{yi} from all moderators
#' in the data.
#' @param data Data.frame. Provide a data.frame containing the effect size,
#' moderators, and the variance of the effect size.
#' Defaults to 100.
#' @param vi Character. Specify the name of the column in the \code{data} that
#' contains the variances of the effect sizes. This column will be removed from
#' the data prior to analysis. Defaults to \code{"vi"}.
#' @param whichweights Character. Indicate what time of weights are required.
#' A random-effects MetaForest is grown by specifying \code{whichweights =
#' "random"}. A fixed-effects MetaForest is grown by specifying
#' \code{whichweights = "fixed"}. An unweighted MetaForest is grown by
#' specifying \code{whichweights = "unif"}. Defaults to \code{"random"}.
#' @param num.trees Atomic integer. Specify the number of trees in the forest.
#' Defaults to 500.
#' @param mtry Atomic integer. Number of candidate moderators available for each
#' split. Defaults to the square root of the number moderators (rounded down).
#' @param method Character. Specify the method by which to estimate the residual
#' variance. Can be set to one of the following: "DL", "HE", "SJ", "ML", "REML",
#' "EB", "HS", or "GENQ". Default is "REML". See the \link[metafor]{metafor} package
#' for more information about these estimators.
#' @param tau2 Numeric. Specify a predetermined value for the residual
#' heterogeneity. Entering a value here supersedes the estimated tau2 value.
#' Defaults to NULL.
#' @param ... Additional arguments are passed directly to \link[ranger]{ranger}.
#' It is recommended not to use additional arguments.
#' @return List of length 3. The "forest" element of this list is an object of
#' class "ranger", containing the results of the random forests analysis. The
#' "rma_before" element is an object of class "rma.uni", containing the results
#' of a random-effects meta-analysis on the raw data, without moderators. The
#' "rma_after" element is an object of class "rma.uni", containing the results
#' of a random-effects meta-analysis on the residual heterogeneity, or the
#' difference between the effect sizes predicted by MetaForest and the observed
#' effect sizes.
#' @import stats
#' @import ranger
#' @import metafor
#' @export
#' @examples
#' set.seed(42)
#' data <- SimulateSMD()
#' mf.unif <- MetaForest(formula = yi ~ ., data = data$training,
#'                       whichweights = "unif", method = "DL")
#' mf.unif
#' mf.random <- MetaForest(formula = yi ~ ., data = data$training,
#'                         whichweights = "random", method = "DL",
#'                         tau2 = 0.0116)
#' mf.random
MetaForest <- function(formula, data, vi = "vi", whichweights = "random",
num.trees = 500, mtry = NULL, method = "REML",
tau2 = NULL, ...) {
args <- match.call()
yi <- as.character(formula[2])
mods <- get_all_vars(formula, data)
if(vi %in% names(mods)) mods <- mods[-match(vi, names(mods))]
vi <- data[[vi]]
data <- mods
rma_before <- metafor::rma(yi = data[[yi]], vi = vi, method = method)
if(is.null(tau2)) tau2 <- rma_before$tau2
if (whichweights == "unif") {
metaweights <- rep(1, nrow(data))
}
if (whichweights == "fixed") {
metaweights <- (1/vi)
}
if (whichweights == "random") {
metaweights <- 1/(vi + tau2)
}
metaweights <- (metaweights/sum(metaweights)) * nrow(data)
mf <- ranger::ranger(formula = formula, data = data, num.trees = num.trees,
mtry = mtry, importance = "permutation", write.forest = TRUE,
case.weights = metaweights, ...)
mf$call <- formula
predicted <- mf$predictions
observed <- data[[yi]]
residuals <- observed - predicted
rma_after <- metafor::rma(yi = residuals, vi = vi, method = method)
output <- list(forest = mf, rma_before = rma_before, rma_after = rma_after, call = args, data = data)
class(output) <- "MetaForest"
output
}
mf.cluster.b1996 <- MetaForest(formula = yi~.,
data, whichweights = "unif", num.trees = 1000)
mf.cluster.b1996
mf.random <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "random", method = "DL",
tau2 = 0.2450)
set.seed(42)
data <- SimulateSMD(k_train = 100, model = es * x[, 1] + es * x[, 2] + es *
x[, 1] * x[, 2])
mf.random <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "random", method = "DL",
tau2 = 0.2450)
mf.random
PartialDependence(mf.random, vars = c("X1", "X2"), interaction = TRUE)
mf.cluster.bd2004 <- MetaForest(formula = yi~ grade + length + minutes + wic +
meta, data, study = "id",
whichweights = "unif")
data <- dat.bangertdrowns2004
data[, c(4:12)] <- apply(data[ , c(4:12)], 2, function(x){
x[is.na(x)] <- median(x, na.rm = TRUE)
x})
data$subject <- factor(data$subject)
data$yi <- as.numeric(data$yi)
mf.cluster.bd2004 <- MetaForest(formula = yi~ grade + length + minutes + wic+
meta, data, study = "id",
meta, data, study = "id",
whichweights = "unif")
mf.cluster.bd2004 <- MetaForest(formula = yi~ grade + length + minutes + wic+
meta, data, study = "id",
whichweights = "unif")
mf.cluster.bd2004 <- MetaForest(formula = yi~ grade + length + minutes + wic+
meta, data, whichweights = "unif")
mf.cluster.bd2004
plot(mf.cluster.bb2004)
plot(mf.cluster.bd2004)
summary(mf.cluster.bd2004, digits = 4)
VarImpPlot(mf.cluster.bd2004)
data <- get(data(dat.bourassa1996))
data <- escalc(measure="OR", ai=lh.le, bi=lh.re, ci=rh.le, di=rh.re, data=data, add=1/2, to="all")
data$mage[is.na(data$mage)] <- median(data$mage, na.rm = TRUE)
data[c(5:8)] <- lapply(data[c(5:8)], factor)
data$yi <- as.numeric(data$yi)
mf.cluster.b1996 <- ClusterMF(formula = yi~ selection + investigator + hand_assess + eye_assess + mage +sex,
data, study = "sample", whichweights = "unif", num.trees = 1000)
mf.cluster.b1996
plot(mf.cluster.b1996)
summary(mf.cluster.b1996, digits = 4)
VarImpPlot(mf.cluster.b1996)
PartialDependence(mf.cluster.b1996, vars = c("mage", "eye_assess"))
PartialDependence(mf.cluster.b1996, vars = c("mage", "eye_assess"), interaction = TRUE)
PartialDependence(mf.cluster.b1996, vars = "eye_assess")
check("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
set.seed(42)
data <- SimulateSMD(k_train = 100, distribution = "bernoulli", model = es *
x[,1]*x[,2])
mf.unif <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "unif", method = "DL")
extract_proximity(mf.unif)
prox_matrix <- extract_proximity(mf.unif)
set.seed(56)
data <- SimulateSMD(k_train = 100, model = es * x[,1] * x[,2])
mf.fixed <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "fixed", method = "DL")
predictions <- predict(mf.fixed, data = data$testing)
predicted <- predict(mf.fixed, data = data$testing)
predicted <- predict(mf.fixed, data = data$testing)$predictions
r2_cv <- sum((predicted - mean(data$training$yi)) ^ 2)/
sum((observed - mean(data$training$yi)) ^ 2)
r2_cv
mean(data$training$yi)
sum((predicted - mean(data$training$yi)) ^ 2)
sum((data$testing$yi - mean(data$training$yi)) ^ 2)
r2_cv <- sum((predicted - mean(data$training$yi)) ^ 2)/
sum((data$testing$yi - mean(data$training$yi)) ^ 2)
r2_cv
mf.fixed
set.seed(11)
data <- SimulateSMD()
mf.fixed <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "fixed")
mf.fixed
set.seed(28)
data <- SimulateSMD()
set.seed(28)
data <- SimulateSMD()
mf.random <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "random")
print(summary(mf.fixed), digits = 3)
set.seed(64)
data <- SimulateSMD()
set.seed(64)
data <- SimulateSMD()
sum <- summary(mf.random <- MetaForest(formula = yi ~ .,
data = data$training, whichweights = "random"), digits = 5)
set.seed(64)
data <- SimulateSMD()
sum <- summary(mf.random <- MetaForest(formula = yi ~ .,
data = data$training, whichweights = "random"), digits = 5)
sum
set.seed(42)
data <- SimulateSMD()
mf.random <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "random", method = "DL",
tau2 = 0.0116)
VarImpPlot(mf.random)
VarImpPlot(mf.random, n.var = 2)
VarImpPlot(mf.random, sort = FALSE)
set.seed(8)
SimulateSMD()
SimulateSMD(k_train = 50, distribution = "bernoulli")
SimulateSMD(distribution = "bernoulli", model = es * x[ ,1] * x[ ,2])
check("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
check("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
devtools::build_win("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
devtools::release("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
devtools::release("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
library(metaforest)
data <- data.frame(SimulateSMD(k_train = 100)$training, study=1:100)
#Run ClusterMF analysis
mf.cluster <- ClusterMF(yi~., data, study = "study")
#Check convergence plot
plot(mf.cluster)
#Check summary
summary(mf.cluster)
#Example 2: Real data from metafor
data <- get(data(dat.bourassa1996))
data <- escalc(measure = "OR", ai = lh.le, bi = lh.re, ci = rh.le, di= rh.re,
data = data, add = 1/2, to = "all")
data$mage[is.na(data$mage)] <- median(data$mage, na.rm = TRUE)
data[c(5:8)] <- lapply(data[c(5:8)], factor)
data$yi <- as.numeric(data$yi)
mf.cluster.b1996 <- ClusterMF(formula = yi~ selection + investigator +
hand_assess + eye_assess + mage +sex,
data, study = "sample",
whichweights = "unif")
#Print MetaForest object
mf.cluster.b1996
#Check convergence plot
plot(mf.cluster.b1996)
#Check summary
summary(mf.cluster.b1996, digits = 4)
#Check variable importance plot
VarImpPlot(mf.cluster.b1996)
#Univariate partial dependence plot
PartialDependence(mf.cluster.b1996, vars = "eye_assess")
install.packages("microbenchmark")
library(microbenchmark)
microbenchmark(
data <- data.frame(SimulateSMD(k_train = 100)$training, study=1:100),
#Run ClusterMF analysis
mf.cluster <- ClusterMF(yi~., data, study = "study"),
#Check convergence plot
plot(mf.cluster),
#Check summary
summary(mf.cluster))
plot(mf.cluster)
data <- get(data(dat.bourassa1996))
data <- escalc(measure = "OR", ai = lh.le, bi = lh.re, ci = rh.le, di= rh.re,
data = data, add = 1/2, to = "all")
data$mage[is.na(data$mage)] <- median(data$mage, na.rm = TRUE)
data[c(5:8)] <- lapply(data[c(5:8)], factor)
data$yi <- as.numeric(data$yi)
mf.cluster.b1996 <- ClusterMF(formula = yi~ selection + investigator +
hand_assess + eye_assess + mage +sex,
data, study = "sample",
whichweights = "unif")
plot(mf.cluster.b1996)
devtools::release("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
data <- get(data(dat.bourassa1996))
data <- escalc(measure = "OR", ai = lh.le, bi = lh.re, ci = rh.le, di= rh.re,
data = data, add = 1/2, to = "all")
data$mage[is.na(data$mage)] <- median(data$mage, na.rm = TRUE)
data[c(5:8)] <- lapply(data[c(5:8)], factor)
data$yi <- as.numeric(data$yi)
devtools::release("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
devtools::release("C:/Users/Caspar/Dropbox/MetaForest/metaforest3/metaforest")
set.seed(42)
data <- SimulateSMD(k_train = 100, model = es * x[, 1] + es * x[, 2] + es *
x[, 1] * x[, 2])
mf.random <- MetaForest(formula = yi ~ ., data = data$training,
whichweights = "random", method = "DL",
tau2 = 0.2450)
mf.random
summary(mf.random)
plot(mf.random)
VarImpPlot(mf.plot)
VarImpPlot(mf.random)
PartialDependence(mf.random)
PartialDependence(mf.random, vars = c("X1", "X2"), interaction = TRUE)
install.packages("metaforest")
install.packages("metaforest")
